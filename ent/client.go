// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/greboid/puzzad/ent/migrate"

	"github.com/greboid/puzzad/ent/access"
	"github.com/greboid/puzzad/ent/adventure"
	"github.com/greboid/puzzad/ent/guess"
	"github.com/greboid/puzzad/ent/progress"
	"github.com/greboid/puzzad/ent/question"
	"github.com/greboid/puzzad/ent/user"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Access is the client for interacting with the Access builders.
	Access *AccessClient
	// Adventure is the client for interacting with the Adventure builders.
	Adventure *AdventureClient
	// Guess is the client for interacting with the Guess builders.
	Guess *GuessClient
	// Progress is the client for interacting with the Progress builders.
	Progress *ProgressClient
	// Question is the client for interacting with the Question builders.
	Question *QuestionClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Access = NewAccessClient(c.config)
	c.Adventure = NewAdventureClient(c.config)
	c.Guess = NewGuessClient(c.config)
	c.Progress = NewProgressClient(c.config)
	c.Question = NewQuestionClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:       ctx,
		config:    cfg,
		Access:    NewAccessClient(cfg),
		Adventure: NewAdventureClient(cfg),
		Guess:     NewGuessClient(cfg),
		Progress:  NewProgressClient(cfg),
		Question:  NewQuestionClient(cfg),
		User:      NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:       ctx,
		config:    cfg,
		Access:    NewAccessClient(cfg),
		Adventure: NewAdventureClient(cfg),
		Guess:     NewGuessClient(cfg),
		Progress:  NewProgressClient(cfg),
		Question:  NewQuestionClient(cfg),
		User:      NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Access.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Access.Use(hooks...)
	c.Adventure.Use(hooks...)
	c.Guess.Use(hooks...)
	c.Progress.Use(hooks...)
	c.Question.Use(hooks...)
	c.User.Use(hooks...)
}

// AccessClient is a client for the Access schema.
type AccessClient struct {
	config
}

// NewAccessClient returns a client for the Access from the given config.
func NewAccessClient(c config) *AccessClient {
	return &AccessClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `access.Hooks(f(g(h())))`.
func (c *AccessClient) Use(hooks ...Hook) {
	c.hooks.Access = append(c.hooks.Access, hooks...)
}

// Create returns a builder for creating a Access entity.
func (c *AccessClient) Create() *AccessCreate {
	mutation := newAccessMutation(c.config, OpCreate)
	return &AccessCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Access entities.
func (c *AccessClient) CreateBulk(builders ...*AccessCreate) *AccessCreateBulk {
	return &AccessCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Access.
func (c *AccessClient) Update() *AccessUpdate {
	mutation := newAccessMutation(c.config, OpUpdate)
	return &AccessUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccessClient) UpdateOne(a *Access) *AccessUpdateOne {
	mutation := newAccessMutation(c.config, OpUpdateOne)
	mutation.user = &a.UserID
	mutation.adventures = &a.AdventureID
	return &AccessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Access.
func (c *AccessClient) Delete() *AccessDelete {
	mutation := newAccessMutation(c.config, OpDelete)
	return &AccessDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for Access.
func (c *AccessClient) Query() *AccessQuery {
	return &AccessQuery{
		config: c.config,
	}
}

// QueryUser queries the user edge of a Access.
func (c *AccessClient) QueryUser(a *Access) *UserQuery {
	return c.Query().
		Where(access.UserID(a.UserID), access.AdventureID(a.AdventureID)).
		QueryUser()
}

// QueryAdventures queries the adventures edge of a Access.
func (c *AccessClient) QueryAdventures(a *Access) *AdventureQuery {
	return c.Query().
		Where(access.UserID(a.UserID), access.AdventureID(a.AdventureID)).
		QueryAdventures()
}

// Hooks returns the client hooks.
func (c *AccessClient) Hooks() []Hook {
	return c.hooks.Access
}

// AdventureClient is a client for the Adventure schema.
type AdventureClient struct {
	config
}

// NewAdventureClient returns a client for the Adventure from the given config.
func NewAdventureClient(c config) *AdventureClient {
	return &AdventureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `adventure.Hooks(f(g(h())))`.
func (c *AdventureClient) Use(hooks ...Hook) {
	c.hooks.Adventure = append(c.hooks.Adventure, hooks...)
}

// Create returns a builder for creating a Adventure entity.
func (c *AdventureClient) Create() *AdventureCreate {
	mutation := newAdventureMutation(c.config, OpCreate)
	return &AdventureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Adventure entities.
func (c *AdventureClient) CreateBulk(builders ...*AdventureCreate) *AdventureCreateBulk {
	return &AdventureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Adventure.
func (c *AdventureClient) Update() *AdventureUpdate {
	mutation := newAdventureMutation(c.config, OpUpdate)
	return &AdventureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdventureClient) UpdateOne(a *Adventure) *AdventureUpdateOne {
	mutation := newAdventureMutation(c.config, OpUpdateOne, withAdventure(a))
	return &AdventureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdventureClient) UpdateOneID(id int) *AdventureUpdateOne {
	mutation := newAdventureMutation(c.config, OpUpdateOne, withAdventureID(id))
	return &AdventureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Adventure.
func (c *AdventureClient) Delete() *AdventureDelete {
	mutation := newAdventureMutation(c.config, OpDelete)
	return &AdventureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AdventureClient) DeleteOne(a *Adventure) *AdventureDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *AdventureClient) DeleteOneID(id int) *AdventureDeleteOne {
	builder := c.Delete().Where(adventure.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdventureDeleteOne{builder}
}

// Query returns a query builder for Adventure.
func (c *AdventureClient) Query() *AdventureQuery {
	return &AdventureQuery{
		config: c.config,
	}
}

// Get returns a Adventure entity by its id.
func (c *AdventureClient) Get(ctx context.Context, id int) (*Adventure, error) {
	return c.Query().Where(adventure.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdventureClient) GetX(ctx context.Context, id int) *Adventure {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Adventure.
func (c *AdventureClient) QueryUser(a *Adventure) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adventure.Table, adventure.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, adventure.UserTable, adventure.UserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestions queries the questions edge of a Adventure.
func (c *AdventureClient) QueryQuestions(a *Adventure) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adventure.Table, adventure.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, adventure.QuestionsTable, adventure.QuestionsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccess queries the access edge of a Adventure.
func (c *AdventureClient) QueryAccess(a *Adventure) *AccessQuery {
	query := &AccessQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adventure.Table, adventure.FieldID, id),
			sqlgraph.To(access.Table, access.AdventuresColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, adventure.AccessTable, adventure.AccessColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AdventureClient) Hooks() []Hook {
	return c.hooks.Adventure
}

// GuessClient is a client for the Guess schema.
type GuessClient struct {
	config
}

// NewGuessClient returns a client for the Guess from the given config.
func NewGuessClient(c config) *GuessClient {
	return &GuessClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `guess.Hooks(f(g(h())))`.
func (c *GuessClient) Use(hooks ...Hook) {
	c.hooks.Guess = append(c.hooks.Guess, hooks...)
}

// Create returns a builder for creating a Guess entity.
func (c *GuessClient) Create() *GuessCreate {
	mutation := newGuessMutation(c.config, OpCreate)
	return &GuessCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Guess entities.
func (c *GuessClient) CreateBulk(builders ...*GuessCreate) *GuessCreateBulk {
	return &GuessCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Guess.
func (c *GuessClient) Update() *GuessUpdate {
	mutation := newGuessMutation(c.config, OpUpdate)
	return &GuessUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GuessClient) UpdateOne(gu *Guess) *GuessUpdateOne {
	mutation := newGuessMutation(c.config, OpUpdateOne, withGuess(gu))
	return &GuessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GuessClient) UpdateOneID(id int) *GuessUpdateOne {
	mutation := newGuessMutation(c.config, OpUpdateOne, withGuessID(id))
	return &GuessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Guess.
func (c *GuessClient) Delete() *GuessDelete {
	mutation := newGuessMutation(c.config, OpDelete)
	return &GuessDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GuessClient) DeleteOne(gu *Guess) *GuessDeleteOne {
	return c.DeleteOneID(gu.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *GuessClient) DeleteOneID(id int) *GuessDeleteOne {
	builder := c.Delete().Where(guess.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GuessDeleteOne{builder}
}

// Query returns a query builder for Guess.
func (c *GuessClient) Query() *GuessQuery {
	return &GuessQuery{
		config: c.config,
	}
}

// Get returns a Guess entity by its id.
func (c *GuessClient) Get(ctx context.Context, id int) (*Guess, error) {
	return c.Query().Where(guess.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GuessClient) GetX(ctx context.Context, id int) *Guess {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQuestion queries the question edge of a Guess.
func (c *GuessClient) QueryQuestion(gu *Guess) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(guess.Table, guess.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, guess.QuestionTable, guess.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(gu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a Guess.
func (c *GuessClient) QueryTeam(gu *Guess) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(guess.Table, guess.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, guess.TeamTable, guess.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(gu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GuessClient) Hooks() []Hook {
	return c.hooks.Guess
}

// ProgressClient is a client for the Progress schema.
type ProgressClient struct {
	config
}

// NewProgressClient returns a client for the Progress from the given config.
func NewProgressClient(c config) *ProgressClient {
	return &ProgressClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `progress.Hooks(f(g(h())))`.
func (c *ProgressClient) Use(hooks ...Hook) {
	c.hooks.Progress = append(c.hooks.Progress, hooks...)
}

// Create returns a builder for creating a Progress entity.
func (c *ProgressClient) Create() *ProgressCreate {
	mutation := newProgressMutation(c.config, OpCreate)
	return &ProgressCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Progress entities.
func (c *ProgressClient) CreateBulk(builders ...*ProgressCreate) *ProgressCreateBulk {
	return &ProgressCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Progress.
func (c *ProgressClient) Update() *ProgressUpdate {
	mutation := newProgressMutation(c.config, OpUpdate)
	return &ProgressUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgressClient) UpdateOne(pr *Progress) *ProgressUpdateOne {
	mutation := newProgressMutation(c.config, OpUpdateOne, withProgress(pr))
	return &ProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgressClient) UpdateOneID(id int) *ProgressUpdateOne {
	mutation := newProgressMutation(c.config, OpUpdateOne, withProgressID(id))
	return &ProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Progress.
func (c *ProgressClient) Delete() *ProgressDelete {
	mutation := newProgressMutation(c.config, OpDelete)
	return &ProgressDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgressClient) DeleteOne(pr *Progress) *ProgressDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ProgressClient) DeleteOneID(id int) *ProgressDeleteOne {
	builder := c.Delete().Where(progress.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgressDeleteOne{builder}
}

// Query returns a query builder for Progress.
func (c *ProgressClient) Query() *ProgressQuery {
	return &ProgressQuery{
		config: c.config,
	}
}

// Get returns a Progress entity by its id.
func (c *ProgressClient) Get(ctx context.Context, id int) (*Progress, error) {
	return c.Query().Where(progress.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgressClient) GetX(ctx context.Context, id int) *Progress {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Progress.
func (c *ProgressClient) QueryUser(pr *Progress) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(progress.Table, progress.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, progress.UserTable, progress.UserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdventure queries the adventure edge of a Progress.
func (c *ProgressClient) QueryAdventure(pr *Progress) *AdventureQuery {
	query := &AdventureQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(progress.Table, progress.FieldID, id),
			sqlgraph.To(adventure.Table, adventure.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, progress.AdventureTable, progress.AdventureColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a Progress.
func (c *ProgressClient) QueryQuestion(pr *Progress) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(progress.Table, progress.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, progress.QuestionTable, progress.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProgressClient) Hooks() []Hook {
	return c.hooks.Progress
}

// QuestionClient is a client for the Question schema.
type QuestionClient struct {
	config
}

// NewQuestionClient returns a client for the Question from the given config.
func NewQuestionClient(c config) *QuestionClient {
	return &QuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `question.Hooks(f(g(h())))`.
func (c *QuestionClient) Use(hooks ...Hook) {
	c.hooks.Question = append(c.hooks.Question, hooks...)
}

// Create returns a builder for creating a Question entity.
func (c *QuestionClient) Create() *QuestionCreate {
	mutation := newQuestionMutation(c.config, OpCreate)
	return &QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Question entities.
func (c *QuestionClient) CreateBulk(builders ...*QuestionCreate) *QuestionCreateBulk {
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Question.
func (c *QuestionClient) Update() *QuestionUpdate {
	mutation := newQuestionMutation(c.config, OpUpdate)
	return &QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionClient) UpdateOne(q *Question) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestion(q))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionClient) UpdateOneID(id int) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestionID(id))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Question.
func (c *QuestionClient) Delete() *QuestionDelete {
	mutation := newQuestionMutation(c.config, OpDelete)
	return &QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionClient) DeleteOne(q *Question) *QuestionDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *QuestionClient) DeleteOneID(id int) *QuestionDeleteOne {
	builder := c.Delete().Where(question.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionDeleteOne{builder}
}

// Query returns a query builder for Question.
func (c *QuestionClient) Query() *QuestionQuery {
	return &QuestionQuery{
		config: c.config,
	}
}

// Get returns a Question entity by its id.
func (c *QuestionClient) Get(ctx context.Context, id int) (*Question, error) {
	return c.Query().Where(question.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionClient) GetX(ctx context.Context, id int) *Question {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAdventure queries the adventure edge of a Question.
func (c *QuestionClient) QueryAdventure(q *Question) *AdventureQuery {
	query := &AdventureQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(adventure.Table, adventure.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, question.AdventureTable, question.AdventureColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionClient) Hooks() []Hook {
	return c.hooks.Question
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAdventures queries the adventures edge of a User.
func (c *UserClient) QueryAdventures(u *User) *AdventureQuery {
	query := &AdventureQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(adventure.Table, adventure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.AdventuresTable, user.AdventuresPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgress queries the progress edge of a User.
func (c *UserClient) QueryProgress(u *User) *ProgressQuery {
	query := &ProgressQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(progress.Table, progress.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.ProgressTable, user.ProgressPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccess queries the access edge of a User.
func (c *UserClient) QueryAccess(u *User) *AccessQuery {
	query := &AccessQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(access.Table, access.UserColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, user.AccessTable, user.AccessColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
